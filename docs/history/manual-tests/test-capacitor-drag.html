<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ç”µå®¹å™¨æ‹–æ‹½æµ‹è¯•</title>
    <style>
        body {
            margin: 20px;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #333;
            cursor: crosshair;
        }
        .info {
            margin: 20px 0;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 5px;
        }
        .status {
            margin: 5px 0;
            padding: 5px;
            font-family: monospace;
        }
        .inside { color: #00aa00; }
        .outside { color: #aa0000; }
    </style>
</head>
<body>
    <h1>å¹³è¡Œæ¿ç”µå®¹å™¨æ‹–æ‹½æµ‹è¯•</h1>
    
    <div class="info">
        <h3>æ“ä½œè¯´æ˜</h3>
        <p>ğŸ–±ï¸ <strong>é¼ æ ‡ç§»åŠ¨</strong>: æŸ¥çœ‹å…‰æ ‡ä½ç½®æ˜¯å¦åœ¨ç”µå®¹å™¨å†…</p>
        <p>ğŸ–±ï¸ <strong>ç‚¹å‡»æ‹–æ‹½</strong>: å°è¯•æ‹–åŠ¨ç”µå®¹å™¨</p>
        <p>ğŸ“ <strong>ç»¿è‰²</strong> = åœ¨ç”µå®¹å™¨å†…ï¼Œ<strong>çº¢è‰²</strong> = åœ¨å¤–é¢</p>
    </div>
    
    <canvas id="canvas" width="800" height="600"></canvas>
    
    <div class="info">
        <div id="status"></div>
    </div>

    <script type="module">
        import { ParallelPlateCapacitor } from '../../../js/objects/ParallelPlateCapacitor.js';
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        
        let capacitor = new ParallelPlateCapacitor({
            x: 400,
            y: 300,
            width: 200,
            plateDistance: 80,
            strength: 1000,
            direction: 0,
            polarity: 1
        });
        
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let mousePos = { x: 0, y: 0 };
        let isInside = false;
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶ææ¿
            const plateAngle = (capacitor.direction + 90) * Math.PI / 180;
            const cosPlate = Math.cos(plateAngle);
            const sinPlate = Math.sin(plateAngle);
            
            const fieldAngle = capacitor.direction * Math.PI / 180;
            const cosField = Math.cos(fieldAngle);
            const sinField = Math.sin(fieldAngle);
            
            const halfWidth = capacitor.width / 2;
            const halfDist = capacitor.plateDistance / 2;
            
            // ç¬¬ä¸€å—æ¿
            const plate1X1 = capacitor.x - cosPlate * halfWidth - cosField * halfDist;
            const plate1Y1 = capacitor.y - sinPlate * halfWidth - sinField * halfDist;
            const plate1X2 = capacitor.x + cosPlate * halfWidth - cosField * halfDist;
            const plate1Y2 = capacitor.y + sinPlate * halfWidth - sinField * halfDist;
            
            // ç¬¬äºŒå—æ¿
            const plate2X1 = capacitor.x - cosPlate * halfWidth + cosField * halfDist;
            const plate2Y1 = capacitor.y - sinPlate * halfWidth + sinField * halfDist;
            const plate2X2 = capacitor.x + cosPlate * halfWidth + cosField * halfDist;
            const plate2Y2 = capacitor.y + sinPlate * halfWidth + sinField * halfDist;
            
            // ç»˜åˆ¶è¾¹ç•Œæ¡†ï¼ˆæ·¡è‰²ï¼‰
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(plate1X1, plate1Y1);
            ctx.lineTo(plate2X1, plate2Y1);
            ctx.lineTo(plate2X2, plate2Y2);
            ctx.lineTo(plate1X2, plate1Y2);
            ctx.closePath();
            ctx.stroke();
            ctx.setLineDash([]);
            
            // ç»˜åˆ¶ææ¿
            ctx.strokeStyle = capacitor.polarity > 0 ? '#0088ff' : '#ff4444';
            ctx.lineWidth = 4;
            
            ctx.beginPath();
            ctx.moveTo(plate1X1, plate1Y1);
            ctx.lineTo(plate1X2, plate1Y2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(plate2X1, plate2Y1);
            ctx.lineTo(plate2X2, plate2Y2);
            ctx.stroke();
            
            // ç»˜åˆ¶ä¸­å¿ƒç‚¹
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(capacitor.x, capacitor.y, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶å…‰æ ‡ä½ç½®
            if (mousePos.x > 0 && mousePos.y > 0) {
                ctx.fillStyle = isInside ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(mousePos.x, mousePos.y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // ç»˜åˆ¶è¿æ¥çº¿
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                ctx.moveTo(capacitor.x, capacitor.y);
                ctx.lineTo(mousePos.x, mousePos.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // å¦‚æœæ­£åœ¨æ‹–æ‹½ï¼Œæ˜¾ç¤ºé«˜äº®
            if (isDragging) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(plate1X1, plate1Y1);
                ctx.lineTo(plate2X1, plate2Y1);
                ctx.lineTo(plate2X2, plate2Y2);
                ctx.lineTo(plate1X2, plate1Y2);
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        function updateStatus() {
            const dx = mousePos.x - capacitor.x;
            const dy = mousePos.y - capacitor.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // è®¡ç®—æŠ•å½±
            const plateAngle = (capacitor.direction + 90) * Math.PI / 180;
            const cosPlate = Math.cos(plateAngle);
            const sinPlate = Math.sin(plateAngle);
            
            const fieldAngle = capacitor.direction * Math.PI / 180;
            const cosField = Math.cos(fieldAngle);
            const sinField = Math.sin(fieldAngle);
            
            const alongPlate = dx * cosPlate + dy * sinPlate;
            const alongField = dx * cosField + dy * sinField;
            
            statusDiv.innerHTML = `
                <div class="status"><strong>å…‰æ ‡ä½ç½®:</strong> (${mousePos.x.toFixed(0)}, ${mousePos.y.toFixed(0)})</div>
                <div class="status"><strong>ç”µå®¹å™¨ä¸­å¿ƒ:</strong> (${capacitor.x.toFixed(0)}, ${capacitor.y.toFixed(0)})</div>
                <div class="status"><strong>è·ç¦»ä¸­å¿ƒ:</strong> ${distance.toFixed(1)} px</div>
                <div class="status"><strong>æ²¿ææ¿æ–¹å‘æŠ•å½±:</strong> ${alongPlate.toFixed(1)} (èŒƒå›´: Â±${(capacitor.width/2).toFixed(1)})</div>
                <div class="status"><strong>æ²¿ç”µåœºæ–¹å‘æŠ•å½±:</strong> ${alongField.toFixed(1)} (èŒƒå›´: Â±${(capacitor.plateDistance/2).toFixed(1)})</div>
                <div class="status ${isInside ? 'inside' : 'outside'}"><strong>åœ¨ç”µå®¹å™¨å†…:</strong> ${isInside ? 'âœ“ æ˜¯' : 'âœ— å¦'}</div>
                <div class="status"><strong>æ‹–æ‹½çŠ¶æ€:</strong> ${isDragging ? 'ğŸŸ¢ æ‹–æ‹½ä¸­' : 'âšª æœªæ‹–æ‹½'}</div>
            `;
        }
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;
            
            isInside = capacitor.containsPoint(mousePos.x, mousePos.y);
            
            if (isDragging) {
                capacitor.x = mousePos.x - dragOffset.x;
                capacitor.y = mousePos.y - dragOffset.y;
            }
            
            draw();
            updateStatus();
        });
        
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (capacitor.containsPoint(x, y)) {
                isDragging = true;
                dragOffset.x = x - capacitor.x;
                dragOffset.y = y - capacitor.y;
                canvas.style.cursor = 'grabbing';
                console.log('å¼€å§‹æ‹–æ‹½ç”µå®¹å™¨');
            } else {
                console.log('ç‚¹å‡»ä½ç½®ä¸åœ¨ç”µå®¹å™¨å†…');
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            if (isDragging) {
                console.log('åœæ­¢æ‹–æ‹½');
            }
            isDragging = false;
            canvas.style.cursor = 'crosshair';
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'crosshair';
        });
        
        draw();
        console.log('ç”µå®¹å™¨æ‹–æ‹½æµ‹è¯•é¡µé¢å·²åŠ è½½');
        console.log('ç”µå®¹å™¨å‚æ•°:', capacitor);
    </script>
</body>
</html>
